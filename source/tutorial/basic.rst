将AIL用于计算
=============

数字
####

在AIL中，数字分为 **浮点数** 和 **整数** ，对于整数，只要内存允许，则其最大值可以很大...很大...。但对于浮点数，只能使用64位浮点数。

::

    >> 3
    < 3 >
    >> 1000
    < 1000 >
    >> 3.0
    < 3.0 >
    >> 50.13
    < 50.13 >

*值得注意的是，在交互环境中，数字总是以被尖括号包裹的形式出现*

与此同时，AIL提供了对二进制，十六进制数字表示的支持。对于16进制，则需要以 :code:`0x` 开头，而对于二进制，则需要以 :code:`0b` 开头。

::

    >> 0xff
    < 255 >
    >> 0b100
    < 4 >
    >> 0b5013
    < -1 >


*需要注意的是，当表示二进制时，0b后的数字串不符合 0 or 1 的规定，则该数字被判断为无效，最终该数字的值就会是 -1。*


运算
####

像计算器一样，AIL也支持简单的运算符，如 :code:`+`, :code:`-`, :code:`*`, :code:`/` 这类四则运算。通常使用它们不必担心过多的问题。但值得注意的是， **除法的运算结果，通常都是浮点数，无论参与计算的两者的类型是浮点数还是整数。** 。

::

    >> 1 + 2
    < 3 >
    >> 1 * 2
    < 2 >
    >> 1 / 1
    < 1.0 >


除了简单四则运算，AIL还提供了两个更高级的运算符：:code:`mod` 和 :code:`//` 。mod ，显而易见，就是模运算(modulus)。而对于  :code:`//` ，对应的运算就是向下取整除(floor division)，其有一个更为通俗的名字，地板除法。

::

    >> 1 mod 2
    < 1 >
    >> -1 mod 2
    < 1 >
    >> 9 mod 3
    < 0 >
    >> 1 // 2
    < 1 >


当然，复合表达式运算也不再话下。表示子表达式，只需要将表达式用小括号 :code:`( )` 阔起来即可

::
    
    >> 3 + 2 / (5 * 6)
    < 0.16666666666666666 >


字符串
######

除了操作数字，AIL也可以操作字符串。但相对于数字运算，字符串操作就没这么多样了。

要表示一个字符串，必须使用 :code:`'` 或者 :code:`"` 阔起。AIL不允许两者混用：即开头是 :code:`"` ，但却以 :code:`'` 结尾，或者反过来。这是不允许的（也是不恰当的）。

::

    >> "nezha"
    'nezha'
    >> 'aobing'
    'aobing'
    >> 'nezha"
    File: '.temp.tmp', line 1:
       'nezha"
    Error: EOL while scanning string literal


AIL为字符串只提供了一种运算：加法。字符串加法规定，两者相加，类型只能是数字或字符串。

::

    >> 'nezha' + ' and ' + 'aobing'
    'nezha and aobing'
    >> 'nezha is ' + 3 + ' years old'
    'nezha is 3 years old'


AIL也提供了对 *部分* 转义字符的支持。

::

    >> print 'Name\tAge\tSex\nNezha\t3\tMale'
    Name    Age     Sex
    Nezha   3       Male


AIL对多行字符串也提供了支持。如何表示多行字符串呢？答案很简单，就像普通字符串一样去表示它！（当然，这种办法在交互模式下行不通）。

::

    print 'What is that?
    It is AIL!'

    /* Output:
    What is that?
    It is AIL!
    */


小结
####

本章讲述了如何使用AIL来进行简单的运算。分别介绍了数字，字符串的表示方式和基本操作。这些操作，将会贯穿整个AIL程序编写过程，十分重要！

